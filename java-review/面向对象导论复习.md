## 面向对象导论复习

### 第二章、java语言基础

> 2/5/7

#### 1.标识符、关键字、分隔符、注释

- 标识符：必须以英文字母（区分大小写）、下划线、美元符号$开头，==不能以数字开头==，不能与关键字同名
- 注释符
  - 行注释符
  - 块注释符
  - 文档注释符（通过Javadoc生产API文档）

#### 2. 基本数据类型，常量

```mermaid
graph LR
数据类型-->基本数据类型
数据类型-->引用数据类型
基本数据类型-->数值型
基本数据类型-->字符型char
基本数据类型-->布尔型Boolean
数值型-->整数类型byte/short/int/long
数值型-->浮点型float/double
引用数据类型-->类
引用数据类型-->接口
引用数据类型-->数组
```

- |  类型  | 字节  |
  | :----: | :---: |
  |  byte  |   1   |
  | short  |   2   |
  |  int   |   4   |
  |  long  | ==8== |
  | float  | ==4== |
  | double | ==8== |

- 浮点型常量默认是double，若要声明为float，需在数字末尾加 ‘ f ’ 或 ‘ F ’

- ```java
  float f = 3.14;	// 错误，doule不能赋值给float（需要强转）
  ```

##### （1）类型转换

- 数值类型转换

  - 低向高：自动类型转换

  - 高向低：强制类型转换（可能精度丢失）

    - ```java
      double b = 35.45000076293945;
      i = (int)b;	// 2147483647  即使b不大也会造成误差巨大
      ```

      

- 字符串转数字

  - ```java
    int x1 = Interger.parseInt("260");
    ```

  - ```java
    float f = Float.parseInt("23.5");
    double d = Double.parseInt("45.6");
    ```

##### （2）字符类型 char

- java的char类型是UTF-16 的code unit。（每个字符都有对应的Unicode码，直接用Unicode表示：'\uXXXX'，每个X表示一个16进制数）
- 转移字符

##### （3）布尔类型 boolean

- ==只允许用true和false==

##### （4）常量和变量

- 直接常量

- 符号常量

  - [修饰符]  ==final==  类型标识符  常量名[=常量]

  - ```java
    public final static double PI = 3.1415926535
    ```

- 变量

  - [修饰符]  类型标识符  变量名[=常量]

#### 3. 控制流程

条件、循环、跳转

```java
switch (表达式) {
		case 常量值1:
			break;
		case 常量值2:
			break;
		...
		
		default:
			break;
}
```

- 跳转：break；continue；return

#### 4. 输入输出

##### （1）输入

System.in是一个InputStream（字节输入流）类的对象，通常不直接使用它来读取用户键盘的输入。而是采取两种常用的封装方式：

-  使用字符流对System.in进行封装

  - ```java
    BufferedReader stdin = new BufferedReader(new InputStreamReader(System.in));
    String str = stdin.readline();
    ```

    

- 使用java.util.Scanner对System.in封装

  - ```java
    Scanner scan = new Scanner(System.in);
    int num = scan.nextInt();
    String str = scan.nextline();
    ```

##### （2）输出

System.out是一个PrintStream类对象，可调用print、println、write方法

print与println的区别在于末尾是否换行；write用来输出字节数组，不换行（网上说write是字符流？😵）



#### 5. 数组

![image-20220531221458912](image-20220531221458912.png)

##### （1）声明与创建

- ```java
  int[] a;
  或
  int a[];
  ```

- ``` java
  int[] c = new int[2];
  或
  int[] c = new int[]{0,1};
  ```

##### （2）长度

```java
int[] c = new int[2];
int len = c.length;
```



#### 6. 异常机制

##### try-catch-finally

- try：用于监听，将可能出现异常的代码放在try块内
- catch：用于捕获异常
- finally：==总会被执行==，只有finally块执行完成之后， 才会回来执行try或者catch块中的return或者throw语句，如果finally中使用了 return或者throw等终止方法的语句，则就不会跳回执行，直接停止。



##### throw和throws用法：

- 共同点：消极处理异常的方式，只负责抛出异常，真正处理异常由函数的上层调用处理
- ==区别==：
  - throws用于方法头，表示只是异常的声明，而throw用于方法内部，抛出的是异常对象
  - throws可以一次性抛出多个异常，而throw只能一个



#### 7. java虚拟机与垃圾回收

##### java虚拟机JVM

- JVM是通过软件来模拟java字节码的指令集，是java程序的运行环境
- 特点：
  - 一次编译，到处运行
  - 自动内存管理
  - 自动垃圾回收功能

- JVM体系结构
  - ![image-20220531224533312](image-20220531224533312-16540083350231.png)


##### java堆

- 新生带
- 老年代
- 元空间（永久代）：像一些方法中的操作临时对象，使用物理内存（1.8之后）



##### JVM垃圾回收

- 不同于显示分配器，java使用隐式分配器，程序员只管创建对象使用，回收交给垃圾回收器

- 垃圾回收器在执行引擎中，垃圾回收的主要对象是==JVM堆空间==

- 优点：

  - 对开发者屏蔽了内存管理的细节，提高了开发效率
  - 开发者无权操作内存，减少了内存泄漏的风险

- 缺点：

  - 不受控的垃圾回收会带来多余的时间开销

  ==$JVM\subset JRE\subset JDK$==

  

### 第三章、类和对象

#### 1. 对象和类

面向对象三大特性：

- 封装
- 继承
- 多态



##### 对象与类的区别

- 对象：客观存在的具体实体，具有明确定义的状态（属性）和行为（方法）
- 类：对现实生活中一类具有共同属性和共同操作的对象的抽象
- 类是静态的，对象是动态的



#### 2. 类的声明和构造

类的修饰符：

- public 公共类
- abstract：抽象类
- final：最终类（非继承）
- 缺省时只能被同个包内的类访问和引用



##### 封装性：

- 将属性设置为private，通过getter/setter对属性进行访问
- 优点：
  - 安全性
  - 高内聚：一种对象只做好一件事
  - 低耦合：不同种类的对象的相互依赖尽可能降低
  - 可复用性



##### 构造方法：

- 无返回值；利用this关键字，区分私有变量和输入变量；
- 至少有一个，无定义时系统会产生一个默认构造方法



##### 继承、子类的构造方法

继承的好处：

- 提高程序的抽象程度
- 实现代码重用，提高开发效率和可维护性

子类通过super语句继承父类的构造方法



#### 3. 类的访问域（重要）

![image-20220531232113441](image-20220531232113441.png)

#### 4. static修饰符

##### 静态成员

> 包括静态属性和静态方法、静态块

静态成员随类的加载被静态地分配内存空间、方法地入口地址，不属于某一具体对象私有

- 使用static声明的方法，不能访问非static的属性或方法
- 使用非static声明的方法，可以分为static声明的属性和方法

##### 静态块

- 可以置于类中的任何地方，类中可以有多个static块
- 在类被加载的时候==执行且仅会被执行一次==，按照static块的顺序来执行每个static块
- 一般用来初始化静态属性和调用静态方法



#### 5. 数组

声明时一定要指出数组大小

- ```java
  int[] a;
  或
  int a[];
  ```

- ``` java
  int[] c = new int[2];
  或
  int[] c = new int[]{0,1};
  ```

一些注意点：

- ```java
  String[] names = {"HIT","SZ","C++"};
  String s = names[2];
  names[2] = "Java";
  System.out.println(s);	// C++
  ```

- > ![image-20220601112821705](image-20220601112821705.png)

##### 遍历数组

```java
int[] ns = {1,23,4};
for(int i = 0; i<ns.length; i++){

}
// 或
for(int n : ns){
    
}
```

##### 一些方法

```java
Arrays.sort(ns);
Arrays.toString(ns);
```

##### 多维数组

> 从数组底层的运行机制看，没有多维数组

- 初始化

  - 静态初始化(行数一定要给)

    ```java
    int[][] arr = new int[m][n];
    int[][] arr = new int[m][]; //有m个一维数组，每个一维数组默认初始值为null
    int[][] arr = new int[][3];		// 非法
    ```

  - 动态初始化

    ```java
    int[][] arr = new int[][]{{1,2,3},{2,7},{4,5,6,7}};
    
    int[] x,y[];	//这里x是一维数组，y是二维数组
    ```

##### 对象数组

```java
// 声明
Person[] students;
// 或
Person students[];
// 初始化
Person[] students = new Person[2];
students[0] = new Person();
students[1] = new Person();
```



### 第四章、接口与继承

#### 1. 继承

- 利用extends关键字
- 子类不能直接继承父类的构造方法，需利用super关键字
- 子类能复用父类的属性和方法（权限允许即可），子类能增加一些新的属性和方法

##### 优点：

- 提高代码的可复用性
- 提高程序的扩展性
- 使类与类之间产生了关系，构成了多态的基础

##### 缺点

- 让类的耦合性增强（一个类的改变会影响到其他相关类）



#### 2. 接口与抽象类

##### 抽象类

> 简单说，有抽象方法的类就是抽象类
>
> ==抽象类不能实例化==
>
> ```java
> public abstract class Person{
> 	private String name;
> 	public String getName(){
> 		return name;
> 	}
>     // 抽象方法，没有方法体，用abstract做修饰
> 	public abstract void getMission();
> }
> ```

- 抽象类不能实例化
- 作用：
  - 相当于定义了规范
  - ==只能被继承==，保证子类实现其定义的抽象方法
  - 可用于实现多态

##### 接口

> 没有字段，所有方法都是抽象方法
>
> 可以有属性，但这个属性必须是一个public static final的常量

```java
interface Persom{
	// 抽象方法
	void getDuty();
	void getMission();
}
```

- 当一个具体的class去实现一个interface时，使用implement关键字
- ==一个类可以implement多个interface，而只能extends一个抽象类==
- 若子类为非抽象类，则必须实现接口中的所有抽象方法

有抽象类，为什么还要接口？

- 抽象类解决不了多继承的问题
- 要实现的方法不是当前类的必要方法
- 为不同类型的多个类实现同样的方法



#### 3. 多态与重写

> 多态是同一行为具有多种表现形态的能力，程序中定义的变量和方法在编程时并不确定，而是在程序运行期间才确定。

##### 多态的好处

- 减少耦合
- 增强可替换性
- 增强可扩展1性
- 提高灵活性

##### 使用多态的三个必要条件

- 继承
- 重写
- 父类引用指向子类

##### 多态的实现

> 父类类名  引用名称  =  new  子类类名( );

- 重写

  - 在编译时，只能调用父类中声明的方法，但在运行时，实际执行的是子类重写父类的方法。（总结：左编译，右运行）

    >  ![image-20220601143118960](image-20220601143118960.png)

- 抽象类和抽象方法

  - > ![image-20220601143447846](image-20220601143447846.png)

- 接口

  - > ![image-20220601143907215](image-20220601143907215.png)



#### 4. Java多继承问题

> - 内部类
> - 接口

##### 用内部类实现：

> 内部类具有外部类的所有元素的访问权限
>
> 实现多继承：相当于在一个类的内部声明多个类，这些内部类再分别继承别的类，且都可以获取各自父类的行为。
>
> ![image-20220601212301514](image-20220601212301514.png)

##### 用接口实现

- 用一个接口继承多个接口，然后再用新建的类实现这个接口
- 直接新建一个类实现多个接口



#### 5. 超类与super关键字

##### Object超类

- Object是所有类的始祖，子类都可以使用Object的所有方法
- Object类位于Java.lang包中，编译时会自动导入
- 可以显示继承（extends Object），也可隐式继承（系统默认继承）

- 可以用Object类型的变量引用任何的对象。（可以理解为自动类型提升）

  - ```java
    Object obj = new Student("zhangsan",19);
    ```

  - 不过要对具体内容进行操作时，还需要进行强制类型转化（向下转型）

    - ```java
      Student Zhangsan = (Student)obj;
      ```

- equals方法

  - 用于比较两个对象是否相等，判断两个对象引用指向的是同一个对象

##### super关键字

- 显式地调用父类构造器（不利用super，也会隐式调用父类的空参构造器）
- 访问父类的成员方法和变量



#### 6. 异常的继承框架

> 异常：程序运行时不被期望的事件，它阻止了程序按照程序员的预期正常执行
>
> java内置了一套异常处理机制
>
> 异常是一种class

三种类型的异常

- 检查性异常：编译时不能被简单地忽略
- 运行时异常：是可能被程序员避免的异常，运行时异常可以在编译时被忽略
- 错误：错误不是异常，而是脱离程序员控制的问题。错误在代码中通常被忽略。如栈溢出

##### ![image-20220601235338430](image-20220601235338430.png)



##### 设计自定义异常

- 所有异常类都必须是Throwable的子类
- 自定义一个检查性异常类，需要继承Exception类
- 自定义一个运行时异常类，需要继承RuntimeException类

> ![image-20220602210203634](image-20220602210203634.png)
>
> ![image-20220602210216856](image-20220602210216856.png)



### 第五章、设计模式导论

#### 1. 面向对象设计原则

- 单一职责原则：我就会干一件事，和这个没关系的别找我
- **开闭原则**：对扩展开放，对修改关闭（低耦合、易扩展、可复用）
- 里氏代换原则：一个软件实体如果使用的是一个基类的话，那么一定适用于其子类。即在软件里面，把基类都替换成它的子类，程序的行为没有变化（子类型、青出于蓝）
- 依赖倒转原则：高层模块不应该依赖低层模块，他们都应该依赖抽象，要针对接口编程，不要针对实现编程
- 合成复用原则：合成/聚合比继承更好
- 接口隔离原则：一个类对另一个类的依赖性应当是建立在最小的接口上
- 迪米特法则：一个软件实体应当尽可能少的与其他实体发生相互作用（实际就是低耦合）



#### 2. 设计模式

分类：

- 根据目的来分：
  - 创建型模式：主要特点是==将对象的创建与使用分离==（工厂模式、单例模式）
  - 结构型模式：用于描述如何将类或对象按某种布局组合成更大的结构行
  - 行为型模式：用于描述类或对象之间怎样==相互协作共同完成任务==（观察者模式、策略模式）
- 根据范围来分
  - 类模式：用于处理类与子类的关系，这些关系通过继承来确立，是静态的，在编译时刻便确定下来
  - 对象模式：用于处理对象之间的关系，这些关系通过组合或聚合来实现，在运行时刻是可以变化的，更具多态性



#### 3. 单例模式

> 保证一个类仅有一个实例，并提供一个访问它的全局访问点。

让某个类==只有一个实例对象==，并只有一个取得该实例对象的方法

 --> 将构造器设置为private

 --> 只能通过类内部创建类的对象

 --> 由于外部不能实例化对象，只能调用该类的某个静态方法以返回类内部创建的对象 

--> 静态方法只能访问类中的静态成员变量，所以，指向类内部产生的该类对象的变量也必须定义成静态的

- 饿汉式：在声明静态变量时new一个实例对象，并通过静态方法返回

  - final：防止反射破坏单例

    饿汉式缺点：可能会造成内存空间的浪费

  - ```java
    public class Singleton{
        private static final Singleton instance = new Singleton();
        private Singleton(){}
        public static synchronized Singleton getInstance(){
            return instance;
        }
    }
    ```

    

- 懒汉式：在静态方法内new一个实例对象，并返回。多线程时可能发生问题

  - 解决：通过增加**synchronized**关键字到 getInstance() 方法中，迫使每个线程在进入这个方法之前， 要先等候别的线程离开该方法。也就是说， 不会有两个线程可以同时进入这个方法。但效率会比较低

  - ```java
    public class Singleton{
        private static Singleton instance;
        private Singleton(){}
        public static synchronized Singleton getInstance(){
            if(instance == null){
                instance = new Singleton();
            }
            return instance;
        }
    }
    ```

    

#### 4. 简单工厂模式

> 以pizza举例
>
> 不用简单工厂模式：创建pizza对象由pizzaStore控制，当要创建的pizza改变时，pizzaStore也要改变，不符合开闭原则
>
> 使用简单工厂模式：创建pizza对象由SimplePizzaFactory控制，只需在pizzaStore中创建SimplePizzaFactory并调用createPizza方法传入参数即可创建pizza对象，当要创建的pizza新增或删减时，只需改变SimplePizzaFactory，不需要改变pizzaStore，符合开闭原则

#### 5. 工厂模式



> ![image-20220602214905827](image-20220602214905827.png)
>
> ![image-20220602220013620](image-20220602220013620.png)
>
> ![image-20220602220917134](image-20220602220917134.png)



#### 6.抽象工厂设计模式

产品族与产品等级

> ![image-20220602230520004](image-20220602230520004.png)

新增产品族难，新增产品等级容易

> ![image-20220602225933730](image-20220602225933730.png)
>
> ![image-20220602225952719](image-20220602225952719.png)



### 第六章、软件测试及代码质量保障

#### 1. 软件测试的定义和分类

软件测试：其目的在于校验被测系统是否满足需求，软件测试是以需求为中心，并非以缺陷为中心！

![image-20220602232809340](image-20220602232809340.png)



#### 2. 测试用例

#### 3. 白盒测试

#### 4. 黑盒测试



### 第七章、集合与策略、迭代器模式

#### 1. 集合类概述

> java.util包中提供了一些集合类（容器）
>
> 数组的长度是固定的，集合的长度是可变的；
>
> 数组是用来存放基本类型的数据，==集合用来存放对象的引用==
>
> - 最基本的接口是Collection接口，该接口定义了操作数据的基本方法
> - 常用的集合有List集合、Set集合、Map集合，其中List与Set实现了Collection接口。各接口还提供了不同的实现类

#### 2. 集合的继承框架

#### 3. List接口及其标准实现类ArrayList与LinkedList

#### 4. Set与Map接口

#### 5. 策略模式

#### 6. 迭代器模式







### other

1. Reader 用于读入16位字符，也就是 Unicode 编码的字符；而 InputStream 用于读 入 ASCII 字符和二进制数据。 

2.  

   - 用 Scanner 实现字符串的输入有两种方法，一种是next（），一种nextLine()；
   - next() 一定要读取到有效字符后才可以结束输入，对输入有效字符之前遇到的空格键、Tab键或Enter键等结束符，next() 方法会自动将其去掉，只有在输入有效字符之后，next()方法才将其后输入的空格键、Tab键或Enter键等视为分隔符或结束符。
   - nextLine()方法的结束符只是Enter键。

   原文链接：https://blog.csdn.net/u011489043/article/details/65644104/